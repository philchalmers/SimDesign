% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/descript.R
\name{descript}
\alias{descript}
\title{Compute univariate descriptive statistics}
\usage{
descript(
  df,
  funs = c(n = length, mean = mean, trimmed = function(x) mean(x, trim = 0.1), sd = sd,
    mad = mad, skewness = EnvStats::skewness, kurtosis = EnvStats::kurtosis, min = min,
    Q_25 = function(x) quantile(x, 0.25), Q_50 = median, Q_75 = function(x) quantile(x,
    0.75), max = max),
  discrete = FALSE
)
}
\arguments{
\item{df}{a data.frame or tibble containing the variables of interest.
Note that \code{factor} and \code{character} vectors will be treated as
discrete observations}

\item{funs}{functions to apply when \code{discrete = FALSE}. Can be modified
 by the user to include or exclude further functions, however each supplied
 function must return a scalar.

 Default functions returns:

 \describe{
  \item{\code{n}}{number of non-missing observations}
  \item{\code{mean}}{mean}
  \item{\code{trimmed}}{trimmed mean (10\%)}
  \item{\code{sd}}{standard deviation}
  \item{\code{mad}}{mean absolute deviation}
  \item{\code{skewness}}{skewness (from \code{EnvStats})}
  \item{\code{kurtosis}}{kurtosis (from \code{EnvStats})}
  \item{\code{min}}{minimum}
  \item{\code{Q_25}}{25\% quantile}
  \item{\code{Q_50}}{50\% quantile (a.k.a., the median)}
  \item{\code{Q_75}}{75\% quantile}
  \item{\code{max}}{maximum}
 }}

\item{discrete}{logical; include summary statistics for \code{discrete}
variables only? If \code{TRUE} then only count and proportion
information will be returned}
}
\description{
Function returns univariate data summaries for each variable supplied, however
discrete and continuous variables are treated separately.
Conditional statistics are evaluated internally using the
\code{\link{by}} function, however group-level specifications are
declared using the \code{dplyr} style inputs; specifically,
\code{\link[dplyr]{group_by}}. Quantitative/continuous variable
information is kept distinct in the output, while \code{discrete} observations
can be returned using the explicit \code{discrete} argument.
}
\examples{

library(dplyr)

data(mtcars)
fmtcars <- within(mtcars, {
	cyl <- factor(cyl)
	am <- factor(am, labels=c('automatic', 'manual'))
	vs <- factor(vs)
})

# with and without factor variables
mtcars |> descript()  # omitted
fmtcars |> descript()  # omitted

# discrete variables only
fmtcars |> descript(discrete=TRUE)

# conditioning
fmtcars |> group_by(cyl) |> descript()
fmtcars |> group_by(cyl, am) |> descript()

# conditioning also works with group_by()
fmtcars |> group_by(cyl) |> descript(discrete=TRUE)
fmtcars |> group_by(cyl, am) |> descript(discrete=TRUE)


}
\seealso{
\code{\link[dplyr]{summarise}}, \code{\link[dplyr]{group_by}}
}
