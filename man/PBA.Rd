% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PBA.R
\name{PBA}
\alias{PBA}
\alias{print.PBA}
\alias{plot.PBA}
\title{Probabilistic Bisection Algorithm}
\usage{
PBA(
  f,
  interval,
  ...,
  p = 0.6,
  integer = FALSE,
  tol = if (integer) 0.01 else 1e-04,
  maxiter = 300L,
  mean_window = 100L,
  f.prior = NULL,
  resolution = 10000L,
  check.interval = TRUE,
  check.interval.only = FALSE,
  verbose = TRUE
)

\method{print}{PBA}(x, ...)

\method{plot}{PBA}(x, type = "posterior", main = "Probabilistic Bisection Posterior", ...)
}
\arguments{
\item{f}{noisy function for which the root is sought}

\item{interval}{a vector containing the end-points of the interval
to be searched for the root}

\item{...}{additional named arguments to be passed to \code{f}}

\item{p}{assumed constant for probability of correct responses (must be > 0.5)}

\item{integer}{logical; should the values of the root be considered integer
or numeric? The former uses a discreet grid to track the updates, while the
latter currently creates a grid with \code{resolution} points}

\item{tol}{tolerance criteria for convergence based on average of the
\code{f(x)} evaluations}

\item{maxiter}{the maximum number of iterations}

\item{mean_window}{last n iterations used to compute the final estimate of the root.
This is used to avoid the influence of the early bisection steps in the
final root estimate}

\item{f.prior}{density function indicating the likely location of the prior
(e.g., if root is within [0,1] then \code{\link{dunif}} works, otherwise custom
functions will be required)}

\item{resolution}{constant indicating the
number of equally spaced grid points to track when \code{integer = FALSE}.}

\item{check.interval}{logical; should an initial check be made to determine
whether \code{f(interval[1L])} and \code{f(interval[2L])} have opposite
signs? Default is TRUE}

\item{check.interval.only}{logical; return only TRUE or FALSE to test
whether there is a likely root given \code{interval}? Setting this to TRUE
can be useful when you are unsure about the root location interval and
may want to use a higher \code{replication} input from \code{\link{SimSolve}}}

\item{verbose}{logical; should the iterations and estimate be printed to the
console?}

\item{x}{an object of class \code{PBA}}

\item{type}{type of plot to draw for PBA object. Can be either 'posterior' or
'history' to plot the PBA posterior distribution or the mediation iteration
 history}

\item{main}{plot title}
}
\description{
The function \code{PBA} searches a specified \code{interval} for a root
(i.e., zero) of the function \code{f(x)} with respect to its first argument.
However, this function differs from deterministic cousins such as
\code{\link{uniroot}} in that \code{f} may contain stochastic error
components, and instead provides a Bayesian interval where the root
is likely to lie. Note that it is assumed that \code{E[f(x)]} is non-decreasing
in \code{x} and that the root is between the search interval.
See Waeber, Frazier, and Henderson (2013) for details.
}
\examples{

# find x that solves f(x) - b = 0 for the following
f.root <- function(x, b = .6) 1 / (1 + exp(-x)) - b
f.root(.3)
retuni <- uniroot(f.root, c(0,1))
retuni
retuni$root

# PBA without noisy root
retpba <- PBA(f.root, c(0,1))
retpba
retpba$root
plot(retpba)
plot(retpba, type = 'history')

\dontrun{

# Same problem, however root function is noisy. Hence, need to solve
#  f(x) - b + e = 0 where eventually E(e) = 0
f.root_noisy <- function(x) 1 / (1 + exp(-x)) - .6 + rnorm(1, sd=.02)
sapply(rep(.3, 10), f.root_noisy)

# uniroot "converges" randomly
set.seed(123)
uniroot(f.root_noisy, c(0,1))$root
uniroot(f.root_noisy, c(0,1))$root
uniroot(f.root_noisy, c(0,1))$root

# probabilistic bisection provides better convergence
retpba.noise <- PBA(f.root_noisy, c(0,1))
retpba.noise
plot(retpba.noise)
plot(retpba.noise, type = 'history')

}
}
\references{
Horstein, M. (1963). Sequential transmission using noiseless feedback.
IEEE Trans. Inform. Theory, 9(3):136-143.

Waeber, R.; Frazier, P. I. & Henderson, S. G. (2013). Bisection Search
with Noisy Responses. SIAM Journal on Control and Optimization,
Society for Industrial & Applied Mathematics (SIAM), 51, 2261-2279.
}
\seealso{
\code{\link{uniroot}}
}
