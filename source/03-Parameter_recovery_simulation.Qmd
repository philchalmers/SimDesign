---
title: "Comparing two estimators and how effectively they recover population parameters"
author: "Phil Chalmers"
format:
  html:
    theme:
      dark: darkly
      light: spacelab
    number_sections: true
    toc: true
    fontsize: 1.1em
---

```{r include=FALSE}
options(digits = 3)
```

Item factor analysis (IFA) is a common method for determine the effectiveness and structure of items in
psychological tests. Two approaches currently exist: full-information IFA via method from the item response
theory framework, and limited-information IFA from the structural equation modeling framework. The question is,
under which circumstances should either method be used? Here we explore a simple one factor test structure
to determine which approach can recover the item parameters when varying test length and sample size.

Unfortunately, the `mirt` package uses a slightly different parameterization of the IFA problem, implementing 
a logistic model rather than a normal ogive model. Historically, the response curves have been equated 
by applying a scaling correction of $D = 1.702$ to help fix this issue, which as can be seen below makes the 
response curves very similar (as it turns out, logistic models have slightly thicker tails than ogive models).

To give the following simulation the benefit of the doubt, the data will be 
generated from the normal ogive model (implying that `lavaan` is fitting the correct model) while `mirt`
is only fitting an approximation to this model by translating the parameters. From this we will see whether
FIML with a logistic model will better approximate the normal ogive parameters compared to the limited information
DWLS approach available in `lavaan`.

```{r}
P_logit <- function(a, d, Theta) exp(a * Theta + d) / (1 + exp(a * Theta + d))
P_ogive <- function(a, d, Theta) pnorm(a * Theta + d)

Theta <- seq(-5,5,length.out=200)
a <- 0.5
d <- -.5
D <- 1.702

example <- data.frame(Theta, logit=P_logit(a*D, d*D, Theta), ogive=P_ogive(a, d, Theta))
plot(Theta, example$logit, type = 'l', ylab = 'P', las=1)
lines(Theta, example$ogive, col = 'red')
```

### Define the conditions

Start by defining the conditions to be studied. Because we are interested in a number of slopes and intercepts
it is often convenient to save long strings of numbers to a single object to be passed to `fixed_objects`.
Naturally, these could be included in the simulation source code directly, but often will take up a large amount
of space (could be hundreds of lines), therefore passing a list object to `runSimulation()` may be more 
convenient. 

```{r}
library(SimDesign)
# SimFunctions()

sample_sizes <- c(250, 500, 1000)
nitems <- c(10, 20)
Design <- createDesign(sample_size = sample_sizes, 
                       nitems = nitems)

# create list of additional parameters which are fixed across conditions
set.seed(1)
pars_10 <- rbind(a = round(rlnorm(10, .3, .5)/1.702, 2),
                 d = round(rnorm(10, 0, .5)/1.702, 2))
pars_20 <- rbind(a = round(rlnorm(20, .3, .5)/1.702, 2),
                 d = round(rnorm(20, 0, .5)/1.702, 2))
(pars <- list(ten=pars_10, twenty=pars_20))
```

```{r eval=FALSE}
# The above slopes, when standardized, give the following factor loadings and commonalities (not run): 
a10 <- pars_10['a', ]; a20 <- pars_20['a', ]
load10 <- a10 / sqrt(1 + a10^2)
load20 <- a20 / sqrt(1 + a20^2)
rbind(F=load10, h2=load10^2)
rbind(F=load20, h2=load20^2)
```

### Define the functions

As usual, define the functions of interest. Here we make sure that `lavaan` and `mirt` are loaded by passing them to the `packages` argument (required when 
running simulations in parallel). Here we only collect information on the slope parameters, mainly because they
are the most interesting to study anyway (intercepts become more important in IRT methods).

```{r}
Generate <- function(condition, fixed_objects = NULL) {

    N <- condition$sample_size
    nitems <- condition$nitems
    nitems_name <- ifelse(nitems == 10, 'ten', 'twenty')

    #extract objects from fixed_objects
    a <- fixed_objects[[nitems_name]]['a', ]
    d <- fixed_objects[[nitems_name]]['d', ]

    dat <- matrix(NA, N, nitems)
    colnames(dat) <- paste0('item_', 1:nitems)
    Theta <- rnorm(N)
    for(j in 1:nitems){
        p <- P_ogive(a[j], d[j], Theta)
        for(i in 1:N)
            dat[i,j] <- sample(c(1,0), 1, prob = c(p[i], 1 - p[i]))
    }
    as.data.frame(dat) #data.frame works nicer with lavaan
}

Analyse <- function(condition, dat, fixed_objects = NULL) {
    nitems <- condition$nitems

    # (optional) could use better starting values from fixed_objects here too
    mod <- mirt(dat, 1L, verbose=FALSE)
    if(!extract.mirt(mod, 'converged')) stop('mirt did not converge')
    cfs <- coef(mod, simplify = TRUE, digits = Inf)
    FIML_as <- cfs$items[,1L] / 1.702

    lavmod <- paste0('F =~ ', paste0('NA*', colnames(dat)[1L], ' + '),
                     paste0(colnames(dat)[-1L], collapse = ' + '),
                     '\nF ~~ 1*F')
    lmod <- sem(lavmod, dat, ordered = colnames(dat))
    if(!lavInspect(lmod, 'converged')) stop('lavaan did not converge')
    cfs2 <- coef(lmod)
    DWLS_alpha <- cfs2[1L:nitems]
    const <- sqrt(1 - DWLS_alpha^2)
    DWLS_as <- DWLS_alpha / const

    ret <- c(FIML_as=unname(FIML_as), DWLS_as=unname(DWLS_as))
    ret
}

Summarise <- function(condition, results, fixed_objects = NULL) {
    nitems <- condition$nitems
    nitems_name <- ifelse(nitems == 10, 'ten', 'twenty')

    #extract objects from fixed_objects
    a <- fixed_objects[[nitems_name]]['a', ]
    pop <- c(a, a)

    obt_bias <- bias(results, pop)
    obt_RMSE <- RMSE(results, pop)
    ret <- c(bias=obt_bias, RMSE=obt_RMSE)
    ret
}
```

Notice that a manual error is throw whenever `lavaan` or `mirt` objects reach their maximum number of 
iterations. This is required because the objects themselves do not throw error messages, but the 
data should be redrawn anyway to ensure that the simulation only contains models which have successfully
converged.

### Run the simulation

Because this simulation takes considerably longer it is recommended to pass the `save = TRUE` to temporarily
save results in case of power outages. Results can be continued by running the identical simulation code as the
initial run, and the function will automatically detect whether any temp files are available and resume the 
simulation at the previously saved location.

```{r cache=TRUE}
res <- runSimulation(Design, replications=100, verbose=FALSE, save=TRUE, parallel=TRUE,
                     generate=Generate, analyse=Analyse, summarise=Summarise, 
                     packages=c('mirt', 'lavaan'), fixed_objects=pars)
res
```

### Analyze the results

Sometimes, reshaping and indexing your output can be very helpful. Here we break the analysis into two parts,
though other strategies are certainly possible. Because analyzing simulations is a lot like analyzing empirical
data no one strategy may be the best; you have to use judgment. 

For this particular analysis, we can see that the `res` object contains NA values for 
slope parameters that were not applicable. For ease of 
manipulating the results it often will be convenient to subset the results so that these NA's are no
longer required.

```{r}
res10 <- subset(res, nitems == 10)
res10 <- res10[,!as.vector(is.na(res10[1L, ]))]
res20 <- subset(res, nitems == 20)
```

#### Ten items

```{r}
# bias in slopes
names10 <- colnames(res10)
bias_as_fiml <- t(res10[,grepl('bias\\.', names10) & grepl('\\_as', names10) & 
                       grepl('FIML', names10)])
colnames(bias_as_fiml) <- sample_sizes
rownames(bias_as_fiml) <- pars_10['a', ]

bias_as_dwls <- t(res10[,grepl('bias\\.', names10) & grepl('\\_as', names10) & 
                       grepl('DWLS', names10)])
colnames(bias_as_dwls) <- sample_sizes
rownames(bias_as_dwls) <- pars_10['a', ]

(out <- list(FIML=bias_as_fiml, DWLS=bias_as_dwls))
sapply(out, colMeans)

# RMSE in slopes
RMSE_as_fiml <- t(res10[,grepl('RMSE\\.', names10) & grepl('\\_as', names10) & 
                       grepl('FIML', names10)])
colnames(RMSE_as_fiml) <- sample_sizes
rownames(RMSE_as_fiml) <- pars_10['a', ]

RMSE_as_dwls <- t(res10[,grepl('RMSE\\.', names10) & grepl('\\_as', names10) & 
                       grepl('DWLS', names10)])
colnames(RMSE_as_dwls) <- sample_sizes
rownames(RMSE_as_dwls) <- pars_10['a', ]

(out <- list(FIML=RMSE_as_fiml, DWLS=RMSE_as_dwls))
sapply(out, colMeans)
```

The methods appeared to recover the slope parameters fairly well, became progressively less biased as 
the sample size increased, and parameters were generally recovered with greater efficiency as $N$ increased 
as well. Additionally, there appeared to be an effect relating to the size of the parameters. For IRT parameters,
very large slopes appeared to be recovered with greater bias compared to the DWLS, though both estimators 
had more difficulty recovering the more extreme slopes (see the RMSE plot below).

```{r}
library(ggplot2)
plt <- data.frame(pars = c(pars_10['a', ], pars_10['a', ]), 
                  RMSE = c(RMSE_as_fiml[,'1000'], RMSE_as_dwls[,'1000']),
                  bias = c(bias_as_fiml[,'1000'], bias_as_dwls[,'1000']),
                  estimator = rep(c('FIML', 'DWLS'), each = 10))
ggplot(plt, aes(pars, bias, colour=estimator)) + geom_point(size=2) + facet_wrap(~estimator) + 
    ggtitle('slope sizes by bias for FIML and DWLS estimators')
ggplot(plt, aes(pars, RMSE, colour=estimator)) + geom_point(size=2) + facet_wrap(~estimator) + 
    ggtitle('slope sizes by RMSE for FIML and DWLS estimators')

```

#### Twenty items

```{r}
# bias in slopes
names20 <- colnames(res20)
bias_as_fiml <- t(res20[,grepl('bias\\.', names20) & grepl('\\_as', names20) & 
                       grepl('FIML', names20)])
colnames(bias_as_fiml) <- sample_sizes
rownames(bias_as_fiml) <- pars_20['a', ]

bias_as_dwls <- t(res20[,grepl('bias\\.', names20) & grepl('\\_as', names20) & 
                       grepl('DWLS', names20)])
colnames(bias_as_dwls) <- sample_sizes
rownames(bias_as_dwls) <- pars_20['a', ]

(out <- list(FIML=bias_as_fiml, DWLS=bias_as_dwls))
sapply(out, colMeans)

# RMSE in slopes
RMSE_as_fiml <- t(res20[,grepl('RMSE\\.', names20) & grepl('\\_as', names20) & 
                       grepl('FIML', names20)])
colnames(RMSE_as_fiml) <- sample_sizes
rownames(RMSE_as_fiml) <- pars_20['a', ]

RMSE_as_dwls <- t(res20[,grepl('RMSE\\.', names20) & grepl('\\_as', names20) & 
                       grepl('DWLS', names20)])
colnames(RMSE_as_dwls) <- sample_sizes
rownames(RMSE_as_dwls) <- pars_20['a', ]

(out <- list(FIML=RMSE_as_fiml, DWLS=RMSE_as_dwls))
sapply(out, colMeans)
```

Again, the estimators appeared to recover the parameters with similar precision and bias. However, the
effect of parameter size now is more evident in the FIML estimator. Larger slopes indeed cause more progressively
bias and larger RMSE values compared to the DWLS estimator. In general, larger slopes when using FIML estimation
will be under-estimated, and therefore have larger RMSEs than the DWLS approach.

```{r}
library(ggplot2)
plt <- data.frame(pars = c(pars_20['a', ], pars_20['a', ]), 
                  RMSE = c(RMSE_as_fiml[,'1000'], RMSE_as_dwls[,'1000']),
                  bias = c(bias_as_fiml[,'1000'], bias_as_dwls[,'1000']),
                  estimator = rep(c('FIML', 'DWLS'), each = 20))
ggplot(plt, aes(pars, bias, colour=estimator)) + geom_point(size=2) + facet_wrap(~estimator) + 
    ggtitle('slope sizes by bias for FIML and DWLS estimators')
ggplot(plt, aes(pars, RMSE, colour=estimator)) + geom_point(size=2) + facet_wrap(~estimator) + 
    ggtitle('slope sizes by RMSE for FIML and DWLS estimators')
```

```{r include=FALSE}
system('rm *.rds')
```
