---
title: "Coverage estimates"
author: "Phil Chalmers"
format:
  html:
    theme:
      dark: darkly
      light: spacelab
    number_sections: true
    toc: true
    fontsize: 1.1em
    embed-resources: true
---

```{r include=FALSE}
options(digits = 3)
```

Coverage relates to how well a proposed confidence interval captures the population parameters. For instance, given some desired nominal error rate, say, $\alpha = .05$, does the confidence interval mean based on a t-test capture the population mean across 95% of the time across random samples? Intervals that are too narrow (i.e., less than the nominal coverage rate) are generally termed 'liberal', while those that are too wide (i.e., greater than the nominal coverage rate) are considered 'conservative'. In the example below we evaluate whether the z or t-distribution is a suitable candidate to capture the population mean across different sample sizes. 

### Define the functions

```{r include=FALSE}
set.seed(1234)
```

```{r}
library(SimDesign)
#SimFunctions(comments = FALSE)

# z-test confidence intervals function
z.CI <- function(dat, alpha = .05){
    xbar <- mean(dat)
    SE <- sd(dat) / sqrt(length(dat))
    z <- abs(qnorm(alpha/2))
    CI <- c(xbar - z * SE, xbar + z * SE)
    CI
}

### Define design conditions. Here we want a finer range of values for plotting
Design <- createDesign(mu = c(0, 5, 10), 
                       sample_size = c(10, 20, 30))

#---------------------------------------------------------------------

Generate <- function(condition, fixed_objects = NULL) {
    ret <- with(condition, rnorm(sample_size, mu))
    ret
}

Analyse <- function(condition, dat, fixed_objects = NULL) {
    t_test <- t.test(dat)
    t_CI <- t_test$conf.int
    z_CI <- z.CI(dat)
    ret <- c(t_CI = ECR(t_CI, parameter = condition$mu), 
             z_CI = ECR(z_CI, parameter = condition$mu)) 
    ret
}

Summarise <- function(condition, results, fixed_objects = NULL) {
    ret <- colMeans(results)
    ret
}

#---------------------------------------------------------------------

### Run the simulation
res <- runSimulation(Design, replications=10000, verbose=FALSE, parallel = TRUE,
                     generate=Generate, analyse=Analyse, summarise=Summarise)
```

```{r}
res
```

From these results it's clear to see that the t-distribution gives very good coverage rates across all conditions. However, the z-distribution CI is too liberal in the smaller sample sizes, and gives an interval that does not contain the population mean as often as desired. Around a sample size of 30 we can see that the two distributions behave reasonably well.

Note that the `ECR()` function was used within the `Analyse()` function rather than in `Summarise()`. When
only the three values are supplied (CIs + population value) then `ECR()` will return either a 1 if the population value was within the CI or 0 if it was not. Hence, in the `Summarise()` function all that is required to obtain the coverage estimate is to find the mean of these 1's and 0's. The next section demonstrates how to use `ECR()` in the `Summarise()` instead, and it's really a matter of preference which style you prefer.

## An Alternative Form

The above simulation called the `ECR()` function within `analyse`, however it is entirely possible to use this function within the `summarise` block by simply supplying matrices of confidence intervals instead.

```{r eval=FALSE}
library(SimDesign)
#SimFunctions(comments = FALSE)

### Define design conditions. Here we want a finer range of values for plotting
Design <- createDesign(mu = c(0, 5, 10), 
                       sample_size = c(10, 20, 30))

z.CI <- function(dat, alpha = .05){
	xbar <- mean(dat)
	SE <- sd(dat) / sqrt(length(dat))
	z <- abs(qnorm(alpha/2))
	CI <- c(xbar - z * SE, xbar + z * SE)
	CI
} 

#-----------------------------------------------------------------

Generate <- function(condition, fixed_objects = NULL) {
    ret <- with(condition, rnorm(sample_size, mu))
    ret
}

Analyse <- function(condition, dat, fixed_objects = NULL) {
    t_test <- t.test(dat)
    t_CI <- t_test$conf.int
    z_CI <- z.CI(dat)
    ret <- c(t_CI = t_CI, z_CI = z_CI) 
    ret
}

Summarise <- function(condition, results, fixed_objects = NULL) {
    ret <- ECR(results, parameter = condition$mu, 
               names = c('t_CI', 'z_CI'))
    ret
}

#-----------------------------------------------------------------

### Run the simulation
res <- runSimulation(Design, replications=10000, verbose=FALSE, parallel = FALSE,
                     generate=Generate, analyse=Analyse, summarise=Summarise)
```


Many secondary function in `SimDesign` have this type of flexibility, therefore it's generally useful to refer to the documentation to help think about easier ways to summarise your results.
